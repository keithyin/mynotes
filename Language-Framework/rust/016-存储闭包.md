# 存储闭包



1. 所有的闭包都 `至少` 实现了 `Fn, FnMut, FnOnce trait` 中的一个

2. 如果一个 `Fn` 闭包的参数是 `u32`, 返回值也是 `u32` 。那么其 trait 约束为 `Fn(u32) -> u32`



## 闭包实际上是一个结构体



```rust
struct Closure {    
    context_env_var1: T // 这个类型可能是 &mut，可能是 &, 也可能是某类型
    // 该类型是根据如何在 闭包使用该变量决定的。
    // 如果是 move || {} ，那么该类型和 环境变量的类型是一致
}
```





## 使用闭包捕获上下文环境

> 此处介绍 闭包什么情况下 会被编译器实现 `Fn, FnMut, FnOnce` 中的哪些 trait

当闭包从环境中捕获值时，它会使用额外的空间来存储这些值，以便在闭包内使用。

闭包可以通过3种方式从环境中捕获值，这和函数接收参数的三种方式是一致的：获取所有权、可变引用和不可变引用。



1. `FnOnce`: 意味着闭包可以从封闭作用域中消耗所捕获的变量。为了实现这一功能，闭包必须在定义时取得这些变量的所有权，并将其移动至闭包中。

2. `FnMut`：可以从环境中可变的借用值并对其进行修改。

3. `Fn`: 可以从环境中不可变的借用值



**当创建闭包时，rust会基于闭包从环境中使用值的方式来自动推导出它需要使用的trait**

1. 所有的闭包都自动实现了 `FnOnce` ，因为他们至少可以被调用一次

2. 不需要移动被捕获变量的闭包还会实现 `FnMut`

3. 不需要对捕获变量进行可变访问的还会实现 `Fn`



什么时候 闭包会仅实现 `FnOnce`

* 当闭包返回了 捕获的环境变量，且该环境变量没有实现`Copy`



什么时候 闭包会实现 `FnMut`

* 当闭包内对于捕获的环境变量执行了 可变值操作时。这时候编译器也会提示在闭包上加一个 mut `let mut closure = || {captured_vec.push(1);}`



如何确定对于闭包的调用是 `call(), call_mut(), call_once()` 呢？

1. 如果闭包返回了捕获的环境变量且返回的环境变量没有实现`Copy`，那么对于闭包的调用一定是 `call_once()`

2. 上述情况除外，如果闭包内有对所捕获的环境变量的 `&mut` 操作，那么一定是调用 `call_mut`

3. 上述情况除外，就是调用 `call`



其他：

1. 如果闭包 实现了 `Fn`, 那么一定也是实现了 `FnMut, FnOnce` 的。所以可以用对应的 trait对象来保存该闭包

2. 如果闭包实现了 `FnMut`, 那么一定也是实现了 `FnOnce` 的。所以可以用对应的 trait对象来保存该闭包



## 关于 move

* `move` 只是将需捕获的上下文变量的所有权转移到了闭包内！


## 闭包作为函数参数

https://stackoverflow.com/questions/66774134/cannot-move-a-value-of-type-dyn-forr-fnoncer-mut-u8-the-size-of-dyn-fo

普通函数可以看做 Fn 闭包！

```rust

fn func2<T>(f: T)
where: T: FnOnce(i32) -> i32
{

}

func(& move|i: i32| i*i);

```

## 


# 参考资料

* https://kaisery.github.io/trpl-zh-cn/ch13-01-closures.html#:~:text=Rust%20%E7%9A%84%E9%97%AD%E5%8C%85%EF%BC%88closures,%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%80%BC%E3%80%82




