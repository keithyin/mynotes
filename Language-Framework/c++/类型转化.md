# C++ 类型转换

[https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used](https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used)



## 隐式类型转换

> 编译器偷偷帮我们做的类型转换

**下面的情况中，编译器会自动地转换运算对象的类型**

* 在多数表达式中： 比 `int` 类型小的整形值首先提升为 较大的整数类型。
* 在条件中：非布尔值 转换成 布尔值
* 初始化过程中，初始值转换成变量的类型 **(通过构造函数)**
* 赋值语句中，右侧运算对象转换成左侧运算对象 (**通过赋值构造函数**)
* 如果 算术运算符 或 关系运算符的运算对象 有多种类型， 需要转换成同一种类型。
* **函数调用时也会发生类型转换**

```c++
 int i = 1;
 double j = 3;
 int b = 2;
 double d = i / b; // 结果是 0， i，b 都是整形，整形除的结果也是整数是 0, 0再转成 double，还是 0
```



## 强制类型转换



**`cast_name<type>(expression)`**

* `type` 是转换的目标类型。如果 `type` 是引用类型, 则结果是**左值**。
* `expression` 是要转换的值。
* `cast-name` 指定了执行的是哪种转换。有以下选择
  * `static_cast`
  * `dynamic_cast`
  * `const_cast`
  * `reinterpret_cast`

**`static_cast`** 

> **任何具有明确定义**  的类型转换， 只要不包含底层 const，都可以使用 static_cast。
>
> 常用来处理显示的进行 隐式转化 (int->float, int* ->void*)
>
> (type) value; 之前这种形式的也可以使用 static_cast
>
> 在 const_cast 部分解释 底层 const



**`const_cast`**

> 只能改变 运算对象的底层 const, 可以加上const, 可以去掉const

```c++
const char * pc; // pc 是底层 const 的，因为它指向了 常量
char *p = const_cast<char*>(pc); // 正确，但是通过 p 写值是未定义的行为
char *ps = static_cast<char*>(pc); // 错误，因为 pc 是底层 const 的。

const int i=0;
int j = static_cast<double>(i); //正确，i 不是底层 const， i 是自身 const
```



```c++
const char *cp;

static_cast<char*>(cp); // 错误：static_cast 不能转换掉 底层 const 性质。
static_cast<string>(cp); // 正确，字符串字面值 转换成 string 类型
const_cast<string>(cp); // 错误， const_cast 只改变 底层常量属性！！！
```



**`reinterpret_cast`**

> 通常为 运算对象的位模式提供较低 层次上的重新解释。
>
> 不能移出掉 const 属性, 只有 const_cast 可行

```c++
int *ip;
char *cp = reinterpret_cast<char*>(ip); //换个角度看 ip ，但是记住：pc 的真实对象依旧是一个 int*
```



**`dynamic_cast`**

> 仅仅用来处理多态 (类别要么生命虚函数, 要么继承了虚函数)
>
> 用于 将基类的 **指针** 或 **引用 ** 安全的转换成 派生类的 **指针** 或 **引用** 
>
> 可以向上转型, 可以向下转型, 
>
> * 如果指针转型失败, 就会返回 nullptr.
> * 如果应用转型失败, 会返回` std::bad_cast`

```c++
dynamic_cast<type*>(e);
dynamic_cast<type&>(e);
dynamic_cast<type&&>(e);
```



**需要转型的类型**

* 类型转换 (`int->float, float->int, int->bool`)
  * `static_cast<target_type>()`
* 有继承层次的类型转换
  * 向父类转型: 这个没有必要使用任何特别指示
  * 像子类转型: 
    * `static_cast<>()` : 可以, 但是不会检查类型转化的正确性
    * `dynamic_cast<>()`: 
* 常量类型转换:
  * `const_cast<>()` : 接触const, 也可以加上 const
* 随意解释







