
* CPU：L1、L2、L3。L1，L2 每个core独占，L3 所有core共享。
  * CPU要读数据，数据会经过 L3，L2，L1
  * CORE的资源：L1、L2缓存，整数计算单元，浮点计算单元
* 内存带宽（GB/s）：



* 线程状态：创建、就绪、运行、终止、阻塞。


获得良好DRAM（内存）性能的规则

1. 粒度（8B ~ 64B）：每次读写的大小应该在 8B ~ 64B之间。太小会导致非常低效
2. 局部性（1KB~4KB）：如果连续访问的内存地址彼此相距太远，他们会触发新的DRAM行读取
3. L1、L2高速缓存（64KB~256KB）：如果单个线程的 **重复** 读或写的字节总数被限制在这么大区域中，则数据可以被L1、L2高速缓存，从而显著提高该线程 **重新** 访问这些数据的速度
4. L3高速缓存（8MB~20MB）：如果 **所有** 线程 **重复** 读或写 的 字节总数被限制在这么大区域中，则数据可以被L3 高速缓存，从而显著提高每个核心的 **重新** 访问速度

把一个大内存的东西复制到一个小的buffer里，然后操作小buffer。这就利用了高速缓存了？不懂。

* 如果一个线程中处理的数据不是内存连续的，那么可以将非连续的数据复制到连续的空间里，然后操作连续空间，然后最后再复制到非连续的空间里

核心密集型：没有使用memcpy。即使也是做了数据的 load 和 store，也是核心密集型的

存储密集型：使用了 memcpy。memcpy是批量内存复制函数，并使用批量内存数据传输完成所有工作，这样可能完全避免核心的参与？ 所以就成了存储密集型

1. 当程序是存储密集型时，其性能严格由内存带宽决定
2. 如果多线程没有得到想要的加速比，那么可能很早就达到了内存带宽的极限


**线程设计的瘦一些**： 什么时胖瘦线程？

* 胖线程没法充分利用 一个core 中的 多个线程。因为 core 级别 共享资源 L1、L2、浮点计算单元，整数计算单元。 这些资源不够分的

SRAM：MOS晶体管做的，MOS晶体管也是CPU和芯片组的基材。速度极快

DRAM：主要是存储电荷的小电容。这些电荷在合适的接口电路配合下被解释成数据。

DRAM需要注意的事情：

* 由于电荷存储在非常小的电容中，因此他会在一段时间（如50ms） 后泄露
* 由于这种泄露，数据必须被读取并写回DRAM（即刷新）
* 考虑刷新的缺点，允许逐字节访问是没有意义的。因此，数据一次以整行的方式访问（例如：一次 4KB） （这里的行是电容排列的物理的行？）
* 尽管一旦读取完成，对改行的访问速度会非常快，但读取一行数据会有较长的延迟
* 除了行访问外，DRAM还有其它延迟，比如 行到行延迟等。这些参数有企业联盟定义的内存接口标准指定。

DRAM接口标准：

* SDRAM
* DDR
* DDR2
* DDR3
* DDR4

DRAM存取特点如下：

1. DRAM一次访问一整行，因而行是DRAM内存的最小存取单元。（2KB ~ 8KB）
2. 访问一行需要一定的时间（延迟）。但是，一旦该行被访问（由DRAM引入到内部的行高速缓冲区内），访问改行就不需要什么消耗。
3. 访问DRAM的延迟为CPU的200 ~ 400个时钟周期，而访问同一行的后续元素只需要几个时钟周期

考虑到DRAM特点，代码应该遵循以下规则：
1. 应该以批量的方式访问远处的 存储器（硬盘 etc），因为我们知道这些数据会存在DRAM中
2. 访问零碎数据应该 保证高度的 局部性和重用性，因为我们知道这些数据会存储到 SRAM中
3. 特别注意多线程，因为内存只有一个，并发会导致不良的DRAM访问模式，尽管他们在一个线程中看起来没有问题
 

SRAM：构成CPU的高速缓冲存储器

* L1：32KB数据缓存，32KB指令缓存。core独享
* L2：256KB，不区分数据和指令.core独享
* L3：15MB。所有core 共享

L1、2、3的载入和替换完全由CPU控制，不受程序员控制。但是程序员可以将数据操作限制在一个**较小的循环中** 来充分利用高速缓存

为了利用高速缓存，代码应该遵循以下规则：

1. 每个线程尽量 **重复访问** 32KB范围内的数据
2. 尽可能的将更大的访问范围限制在 256KB以内
3. 在考虑所有启动线程时，尽量将整体的数据访问规模限制在L3范围内
4. 如果必须超出此范围，请确保在超出该范围之前，L3的使用率很高！

