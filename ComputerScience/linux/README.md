看了这么多，有一种很明显的感觉，linux 数据的元信息 与 数据是分离的。


# 内存管理

* 字/字节：处理器的最小可寻址单位
* 页（物理内存）：内核将其作为内存管理的基本单元

  *  假设一个页 8 KB，物理内存 8G，那么可以分为 1024 * 1024 个页。每个页都对应了一个结构体(struct page)来表示页当前状态
  *  struct page对应的是物理内存，而非虚拟内存
  *  都做了什么管理？
    *  当前页是否空闲
    *  如果不空闲，谁拥有了这个页。拥有者是 用户空间进程、动态分配的内核数据、静态内核代码、页高速缓存？
* 区：多个页会构成一个区，区是按照功能划分的。
  
  *  为了解决硬件存在缺陷而导致的内存寻址问题所存在
  *  缺陷①：一些硬件只能用某些特定的内存地址（物理）来执行DMA（直接内存访问）
  *  缺陷②：一些体系结构的 内存的物理寻址范围比虚拟寻址范围大得多。这样，就有一些内存不能**永久**的映射到内核空间上。
  *  四种区：① ZONE_DMA： 这个区包含的页用来执行DMA操作。②ZONE_DMA32。③ZONE_NORMAL 这个包含的是能正常映射的页。④ZONE_HIGH 该区域包含高端内存，其中的页不能永久的映射到内核地址空间。
  *  linux通过将物理内存的页划分为区，形成不同的内存池，这样就可以根据用途进行分配了。（这里的分配指的是 拿到对应的物理页）
  *  每个区都是使用 `struct zone` 来表示。


*  内核提供了一些函数能够分配页，即：获取可用的页给当前的进程使用！
       
* 页表：


# 虚拟文件系统（VFS）

在真实的文件系统上又封装了一层，用来屏蔽不同文件系统的实现细节

VFS四个主要的对象：

1. 超级块对象
   * 该对象用于存储 特定文件系统的信息，通常对应于存放在 **磁盘特定扇区** 中的 **文件系统超级块** 或 **文件系统控制块**
   * super_operations: 内核针对 特定文件系统所能调用的方法，inode 的 create, destroy, write, drop ... 和 super 的 put, write 和 fs 的 sync, freeze ...
   * 
2. 索引节点对象
   * 包含 内核在操作文件 或 目录时 需要的全部信息。对于unix风格文件系统，这些信息可以从 磁盘索引节点直接导入。
   * 一个索引节点代表文件系统中的一个文件！！（仅当文件被访问时才会被创建）
   * **会记录文件是否是脏的**！！！！
   * inode_operations: 针对特定文件所能调用的方法，比如：create，link。是一些文件创建、删除的操作。
3. 目录项对象：代表的是路径的一个组成部分。
   * VFS将目录当做文件看到。比如在路径 /bin/vi 中。bin 和 vi都属于文件。路径中的每个组成部分都有一个索引节点对象表示。但是VFS经常需要执行目录相关操作，比如路径名查找。路径名查找需要解析路径中的每个组成部分，为了方便查找工作，VFS引入目录项对象。 /bin/vi. /、bin、vi 都是一个目录项对象。
   * dentry_operations: 针对目录所能调用的方法，比如：d_compare, d_delete
4. 文件对象
   * 已打开的文件在内存中的表示，由open创建，close销毁。由于多个进程可能打开同一个文件，所以同一个文件可能对应多个文件对象。同一个文件的inode 和 目录项是唯一的。
   * 针对打开的文件所能调用的方法，read(), write
  

# 块IO层
块设备：能够随机访问固定大小数据片的硬件设备。（磁盘就是一个块设备）

----
扇区：块设备的最小可寻址单元。（多数为512字节）

* 设备上的IO必须以扇区为单位进行操作！但是内核的IO不是。

----
块：最小逻辑可寻址单元。（文件系统的抽象，只能基于块来访问文件系统）

* 内核执行的所有磁盘操作都是按照块进行的。
* 块不能比扇区小，不能比页面大小大。且是2的整数倍。 通常大小为 512B，1KB，4KB
* 当一个块被调入内存时（也就是说，在读入后或等待写出时），要被存储在一个缓冲区中。每个缓冲区与一个块对应，该缓冲区相当于磁盘块在内存中的表示。
* 由于块的大小不能大于页面。所以一个页可以容纳一个或多个内存中的块。由于内核在处理数据时需要一些相关的控制信息，比如：块属于哪一个块设备、块对应哪个缓冲区等，所以每个缓冲区都有一个对应的描述符。该描述符用 buffer_head 表示。


----
bio结构体：内核中块IO操作的基本容器。代表 正在活动的 以 片段链表形式 组织的块IO操作。

* 一个片段是 一小块连续的内存缓冲区。这样就不需要保证 单个缓冲区 一定要连续。所以通过片段来描述缓冲区，即使一个缓冲区分散在内存的多个位置上，bio结构体也能保证IO操作的执行。
* 所以缓冲区可能分散在 多个页上。
* bio的 片段链表 包含了 一个特定IO操作所需要使用的所有片段。
* 每一个块IO请求都用过一个bio结构体表示，每个请求包含一个或多个块

----
请求队列：块设备将挂起的块IO请求保存在请求队列中。然后该队列可以做一些调度工作，比如合并，排序 啥的。


？？？块IO请求是谁提交的？

# 页高速缓存&页回写

页高速缓存：内存中的物理页面组成，内容对应磁盘上的物理块。

进程read调用的流程：①数据是否在页高速缓存。②如果没有，则调度块IO操作从磁盘读取数据，然后内核将读来的数据放到页缓存中。
进程write调用的流程：①直接写到缓存中，后端存储不会立即更新。②一个进程定期将 脏页链表中的页 写回到磁盘。

----
缓存回收：

1. 选择干净页，进行简单替换
2. 如果没有足够干净页，内核强制回写操作

----
address_space对象：页高速缓存中的页可能包含多个不连续的物理磁盘块。所以需要一个新的对象来管理 缓存项 与 页IO操作。其实主要是因为 内存管理单元为页，内核的块设备操作单元 块。一个块会在多个页中，一个页会包含多个快。address_space就是要将这俩给糅合起来。

address_space 和 一个inode关联。表征 文件的 物理地址空间。

1. address_space 表征的是 文件在内存上的物理空间，因此 address_space 会包含多个页
2. 页中包含磁盘的块。这些块也不是连续的。因为 文件在磁盘上存储也不是连续的。

---- 
页回写：每个磁盘一个线程来进行脏页的回写。


# 访问文件




