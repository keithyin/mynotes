1. 阻塞IO，调用一些IO操作会导致block住
2. 非阻塞IO，调用不会阻塞，可以立即返回。（和多线程调用IO效果类似）。该IO对于普通文件的IO是无效的
3. IO多路转接：首先得是非阻塞描述符
    1. 假设有多个输入。哪个输入准备好了，就用哪个输入，这种场景就非常适合IO多路转接
    2. 构造一个感兴趣的文件描述符表，然后调用一个函数，直到表中的某个文件描述符准备好IO时，这个函数才会返回。当这些函数返回时，会告诉我们哪些文件描述符可以进行IO
    3. pool, pselect, select 这三个函数可以让我们能够执行IO多路转接
    4. select：主要用于终端IO和网络IO，在普通文件IO上是不是起作用？

```c
select

/*
select输入：
    1. 我们所关心的描述符
    2. 每个描述符所关系的条件（是想从一个描述符读，还是往一个描述符写，是否关心描述符的异常条件）
    3. 愿意等待多长时间（可以永远等待、等待一个固定时间、根本不等待）

当select返回时，它会告诉我们：
    1. 已准备好的描述符的总数量
    2. 对于读、写、异常这三个条件的每一个，哪些描述符已经准备好

知道哪些描述符准备好之后，就可以进行相应操作了。

注意：如果一个描述符碰到了文件尾端，那么select会认为该描述符是可读的，但是真正去读的时候 read 返回 0

对于准备好的定义：
    1. 对于读集合，如果 read 不会阻塞，那就是准备好的
    2. 对于写集合，如果 write 不会阻塞，就是准备好的
    3. 对于异常集合，如果 存在 未处理的异常，就是准备好的
    4. 对于读、写、异常条件。普通文件的文件描述符总是返回准备好（所以select对于普通文件IO是不生效的！！！）
*/

```

```c
// 返回值表示 满足事件的项数
int poll(struct pollfd fdarray[], ndfs_t nfds, int timeout);

struct {
    int fd;
    short events;  // 感兴趣的事件，由调用者设置。
    short revents; // 发生在 fd 上的事件。由内核设置
}

/*
类似select，但是程序接口不大一样.

*/

```

```c
epoll

```


4. 异步IO：
