# 设计模式总结

编码七大原则:

* 单一职责原则
* 接口隔离原则
* 依赖倒置原则
* 里氏替换原则
* 开闭原则 (最终原则,  以上原则都是为该原则服务的)
* 迪米特法则
* 合成复用原则



什么是设计模式: **解决某类通用问题** 的 **符合编码七大原则** 的设计规则

* 创建型模式:

  *  用来创建对象的 
  * `provide object creation mechanisms that increase flexibility and reuse of existing code.`
    * 单例模式, 工厂模式(简单工厂, 工厂模式, 抽象工厂模式), 原型模式, 建造者模式(只考虑构建对象, 构建对象具有流程)

* 结构型模式:

  *  `explain how to assemble objects and classes into larger structures, while keeping the structures flexible and efficient. `

  * > 将一个对象, 塞到另一个对象中的方法

    * 适配器模式, 桥接模式, 装饰者模式, 组合模式, 外观模式, 享元模式, 代理模式

* 行为型模式: 

  * 对象之间的通信, 谁负责干啥的指导方法
  * `take care of effective communication and the assignment of responsibilities between objects.`
    * 模板方法模式, 命令模式, 访问者模式, 迭代器模式, 观察者模式, 中介者模式, 备忘录模式, 解释器模式, 状态模式, 策略模式, 责任链模式.
  * 

## 设计原则总结

* 找出应用中 **可能变化** 之处，把他们 **独立出来**，不要和那些不需要变化的代码放在一起。

  * 把会变化的部分 **取出并封装** 起来 ，好让其他部分不会受到影响。

    

* 针对接口（**超类/基类**）编程，而不是针对实现编程

  * 在写代码的时候，**形参最好都是接口**，不要用具体的实现，这样的话，可以用简单的任意的实现来给这个 **形参传值 **。 





* **多用组合**, 少用**继承**
* 为了交互对象的 **松耦合** 而努力
* **类应该对扩展开放，对修改关闭** 
* **依赖抽象，不要依赖具体类**
* **好莱坞原则：高层组建对待低层组建的方式，别调用我们，我们会调用你**
* 


## 设计模式总结

----



## 策略模式

**定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户**

* `定义了算法族`： 定义了多个算法类，他们都继承同一个基类
* `可以相互替换`： 因为继承了同一个基类，所以他们之间可以相互替换




**用到的技术**

* 组合：将算法组合起来
* 继承：算法族继承自同一个祖先




## 观察者模式

**特点**

* 让对象知悉现状，不会错过对象感兴趣的事。
* 对象甚至可决定在运行时是是否要继续被通知



**通过例子理解观察者模式**

* 报社的任务是出版报纸
* 向某家报社订阅报纸，如果他们一旦有新报纸，他们就会给你送过去
* 当不想看到报纸时，可以取消订阅

**出版社+订阅者=观察者模式**

* 出版社： 主题
* 订阅者：观察者



**关系**

* 观察者可以订阅主题
* 观察者可以取消订阅主题
* 主题会给订阅的观察者发送消息



**正式定义： 定义了对象的一对多（主题-->观察者）依赖关系，这样一来，当主题改变状态时，它的所有依赖者都会收到通知。**



**实现**

```python
class Subject(object):
    def __init__(self):
        self.observers = []
    def registe_observer(self, o):
        self.observers.append(o)
    def remove_observer(self, o):
        del self.observers[self.observers.index(o)]
    def notify_all(self):
        for obs in self.observers:
            obs.do_something()

class Observer(object):
    def do_something():
        # 当主题通知变化时，应该做什么
        pass
```



## 装饰者模式

**目标**

* 在不修改现有代码的情况下，就可搭配新的行为。



**定义：动态的（意思就是在运行时）将责任附加在对象上。若要扩展功能，装饰者提供了比继承更加有弹性的方案**

* 实际上就是用组合

**实现**

```python
# Decorater 和具体的 Component 都要继承同一个 Component
```



## 工厂模式

**既然一直再说针对接口编程， 那么总要有地方创建实例吧，工厂模式就是答案**



## 单例模式

**You are my only one ! **



## 命令模式

**封装调用**

**动作的请求者 与 动作的执行者 解耦， 因为动作的执行者变化可能会很多**

**考虑一个场景**

有一家餐馆，客人来之后会点餐，服务员会将订单交给厨师，厨师拿着订单做菜。

* 客人： 客户
* 服务员：调用者
* 厨师：接收者、执行者
* 订单：命令对象



在命令模式中，有几个关键点：

* 客户（这个不是个对象）：创建命令对象，与接收者绑定。
* 命令对象（命令模式中的对象）：命令对象其实是个动作，它同时绑定了命令的接收者（执行者）
  * 命令对象有个 `execute()` 方法，用来调用 `接收者`，动作
* 调用者对象（命令模式中的对象）：有个 `setCommand()` 方法，将 `Command` 传给 自己
* 接收者（命令模式中的对象）：实际的操作者

**可以看出，调用者对象 将调用封装起来了。 命令将要执行啥，和由谁执行封装起来。调用者来调用命令中的执行接口，实际上是执行的接收者的执行接口**

```python
remote = SimpleRemoteControl() # 调用者，请求者
light = Light()
lighton = LightOnCommand(light) # 命令 与 接收者封装起来
remote.set_command(lighton)
remote.press_button() # 调用者调用命令
```



## 适配器模式

**目的**

* 将类的接口转化成想要的接口
* 将对象包装起来，赋予他们新的职责
* 将对象包装起来以简化其接口



**适配器**

* 像是一个中间件。

**适配器是个类，继承转换的目的类，绑定要转换的源对象，**

```python
# 此适配器，将 turkey 转成 Duck
class TurkeyAdapter(Duck):
    def __init__(self, turkey):
        self.turkey = turkey
```



**定义**

* 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间



## 模板方法模式

**封装算法**

* 在一个方法中定义了一个算法的骨架，而将骨架中的一些步骤的实现延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤！！！



**用到的技术**

* 继承
* 多态（虚函数）



```python
class Base(object):
    def compute(self):
        self.step1()
        self.step2()
        self.step3()
    def step1(self):
        # 留着子类去实现
        raise NotImplemented
    def step2(self):
        raise NotImplemented
    def step3(self):
        raise NotImplemented
```



## 迭代器与组合模式



## 状态模式

**定义**

* 允许**对象**在内部状态改变时改变它的行为，对象看起来好像修改了它的类。注意是创建出来的对象哦



## 代理模式

你是一个白脸，提供很好且友善的服务，但是你不希望每个人都叫你做事，所以找了个黑脸控制对你的访问。

* 黑脸：代理模式，控制和管理访问



本来是：对象 `A` 直接访问 对象`C`， 加了代理模式之后， 对象`B` 与 `C` 绑定，`A` 通过 访问 `B` 访问 `C`





## 总结

**封装**

* 封装对象创建 ---> 工厂模式
* 封装方法调用 ---> 命令模式
* 封装复杂接口 ---> 适配器模式
* 





## 再总结

**两个对象交互**

* 观察者模式: 一个对象分发, 多个对象接收
* 策略模式: 一个 主调用对象,  一个算法对象 (主调用对象保存一个接口, 该调用的时候就调用了)
* 状态模式: 一个主调对象, 里面包含所有的可能状态对象
  * 主调对象负责调用
  * 状态负责 状态中的转移

**三个对象交互**

* 命令模式: 动作的调用者,  动作, 动作影响的对象
  * 将动作影响的对象封装到 动作中
  * 动作的调用者 只需要保存 即将要执行的动作即可