# 寄存器

## 通用寄存器
> 应用程序代码可以随便用的

| 寄存器 | 描述        |
| ------ | ----------- |
| %rax   | 返回值      |
| %rbx   | callee 保存 |
| %rcx   | 第4个参数   |
| %rdx   | 第3个参数   |
| %rsi   | 第2个参数   |
| %rdi   | 第1个参数   |
| %rbp   | callee保存  |
| %rsp   | 栈指针      |
| %r8    | 第5个参数   |
| %r9    | 第6个参数   |
| %r10   | caller保存  |
| %r11   | caller保存  |
| %r12   | callee保存  |
| %r13   | callee保存  |
| %r14   | callee保存  |
| %r15   | callee保存  |
|        |             |
|        |             |
|        |             |

具有特殊用途的指针

* `%rsp`: 指向栈顶，`push, pop` 操作会对该寄存器又副作用
  * 也可以显示对该寄存器操作。`sub $20, %rsp`

callee保存：**被调用者保证** 该寄存器的值在 `调用返回时` 和 `调用发生时` 的值是一样的。

* `%rbx, %rbp, %r12, %r13, %r14, %r15`
* 即：如果想用这几个寄存器的话，那就记得先将这几个寄存器的值保存起来（栈里）。在函数返回之前复原



caller保存：如果**调用者**使用了这些寄存器，那么在执行 `call` 指令前，要将这些寄存器的值保存。在`call` 之后复位

* `%r10, %r11, %rax, %rcx, %rdx, %rsi, %rdi, %r8, %r9`
* 即：除了 `%rsp` 和 callee 保存的寄存器，剩下的都是 `caller 保存`



管理变长栈帧：

* `%rbp`: base pointer, 基指针 

## GDTR & IDTR
* DGTR: global descriptor table register。指明全局描述表位置的寄存器
* IDTR: interrupt descriptor table register。指明中断描述符表的寄存器

```asm
lgdt operand
lidt operand
```
* operand：是一个6bytes(48bits)的值。前16位表示表的大小，后32位表示表的基址。
https://c9x.me/x86/html/file_module_x86_id_156.html

注意：
* The LGDT and LIDT instructions are used only in operating-system software; they are not used in application programs
* They are the only instructions that directly load a linear address (that is, not a segment-relative address) and a limit in protected mode
* They are commonly executed in real-address mode to allow processor initialization prior to switching to protected mode.


## 段寄存器
* `cs`: 代码段寄存器
* `ds`: 数据段寄存器
* `es`: 附加段寄存器
* `ss`: 栈段寄存器



## GDTR & LDTR

* GDT： global descriptor table: 用来描述程序的段信息的。(内核使用)
* LDT: local descriptor table: 用来描述程序段信息的。（应用程序使用）
* TSS：task state segment: 在一个多任务的环境中，当任务切换发生时，必须保护旧任务的运行状态，或者是保护现场，保护的内容包括通用寄存器、段寄存器、栈指针寄存器ESP、指令指针寄存器EIP、状态寄存器EFLAGS，等等。
  * 对应寄存器：`TR (task register)` 





## 特权级

只能在特权级别执行的操作

* `hlt`： 停机
* `cr0` 的写操作
* `lgdt, lldt, ltr(lode task register), `



# 系统调用

系统调用的所有参数都是通过通用寄存器传递的。

* `%rax` : 存放系统调用号
* `%rcx, %rdx, %rsi, %rdi, %r8, %r9`: 用来存放系统调用参数
* `syscall` : 系统调用指令





----

# X86 汇编

* 实模式 和 保护模式：说的是CPU的工作模式，CPU可以工作在实模式下，也可以工作在保护模式下。设置 寄存器`cr0=1` 来打开保护模式。
  * 实模式特点：直接面对物理内存。每个程序都可以访问任意物理内存位置
  * 保护模式：可以给代码的每个段设置权限，这样就提供了一点保护能力。至少可以保证数据段不会当成代码段执行。



# 实模式到保护模式





# 寻址

实模式：对于x86来说，实模式工作在16bit。使用20bit地址总线

* `段寄存器值 << 4 + 16bit_offset`



保护模式：

* GDT: global descriptor table, 用来设置段的基地址，大小，权限，etc。每条记录 64bits。下面是段的描述
  * <img src="https://img-blog.csdnimg.cn/01bc8c838afb4fe083abfe3865d3d038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0MzYxNDk=,size_16,color_FFFFFF,t_70" alt="image-20210807231950100" style="zoom:50%;" />
    * DPL：Descriptor Privilege Level：描述符特权级
  * `gdtr`: 寄存器，存放指向 GDT的指针。



* 段寄存器用来存取 指向GDT记录的指针偏移（为什么存偏移量即可？因为 gdtr 已经有基地址了）
  * 段寄存器存的值的解释：描述符索引，TI，RPL。描述符索引：13bits，TI：1bits，RPL：2bits
  * 描述符索引：注意是索引号，而非地址偏移！
  * TI = 0，从GDT中找索引。TI=1，从LDT找索引
  * RPL：request privilege level. 请求特权级



谁来设置GDT：

* 运行在最高特权级的代码。（booloader， 操作系统内核，etc）。应用程序就不要想了。

