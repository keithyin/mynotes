# 寄存器

## 通用寄存器
> 应用程序代码可以随便用的

| 寄存器 | 描述        |
| ------ | ----------- |
| %rax   | 返回值      |
| %rbx   | callee 保存 |
| %rcx   | 第4个参数   |
| %rdx   | 第3个参数   |
| %rsi   | 第2个参数   |
| %rdi   | 第1个参数   |
| %rbp   | callee保存  |
| %rsp   | 栈指针      |
| %r8    | 第5个参数   |
| %r9    | 第6个参数   |
| %r10   | caller保存  |
| %r11   | caller保存  |
| %r12   | callee保存  |
| %r13   | callee保存  |
| %r14   | callee保存  |
| %r15   | callee保存  |
|        |             |
|        |             |
|        |             |

具有特殊用途的指针

* `%rsp`: 指向栈顶，`push, pop` 操作会对该寄存器又副作用
  * 也可以显示对该寄存器操作。`sub $20, %rsp`

callee保存：**被调用者保证** 该寄存器的值在 `调用返回时` 和 `调用发生时` 的值是一样的。

* `%rbx, %rbp, %r12, %r13, %r14, %r15`
* 即：如果想用这几个寄存器的话，那就记得先将这几个寄存器的值保存起来（栈里）。在函数返回之前复原



caller保存：如果**调用者**使用了这些寄存器，那么在执行 `call` 指令前，要将这些寄存器的值保存。在`call` 之后复位

* `%r10, %r11, %rax, %rcx, %rdx, %rsi, %rdi, %r8, %r9`
* 即：除了 `%rsp` 和 callee 保存的寄存器，剩下的都是 `caller 保存`



管理变长栈帧：

* `%rbp`: base pointer, 基指针 

## GDTR & IDTR
* DGTR: global descriptor table register。指明全局描述表位置的寄存器
* IDTR: interrupt descriptor table register。指明中断描述符表的寄存器

```asm
lgdt operand
lidt operand
```
* operand：是一个6bytes(48bits)的值。前16位表示表的大小，后32位表示表的基址。
https://c9x.me/x86/html/file_module_x86_id_156.html

注意：
* The LGDT and LIDT instructions are used only in operating-system software; they are not used in application programs
* They are the only instructions that directly load a linear address (that is, not a segment-relative address) and a limit in protected mode
* They are commonly executed in real-address mode to allow processor initialization prior to switching to protected mode.


## 段寄存器
* `cs`: 代码段寄存器
* `ds`: 数据段寄存器
* `es`: 附加段寄存器
* `ss`: 栈段寄存器



## GDTR & LDTR

* GDT： global descriptor table: 用来描述程序的段信息的。(内核使用)
* LDT: local descriptor table: 用来描述程序段信息的。（应用程序使用）
* TSS：task state segment: 在一个多任务的环境中，当任务切换发生时，必须保护旧任务的运行状态，或者是保护现场，保护的内容包括通用寄存器、段寄存器、栈指针寄存器ESP、指令指针寄存器EIP、状态寄存器EFLAGS，等等。
  * 对应寄存器：`TR (task register)` 





## 特权级

只能在特权级别执行的操作

* `hlt`： 停机
* `cr0` 的写操作
* `lgdt, lldt, ltr(lode task register), `



# 系统调用

系统调用的所有参数都是通过通用寄存器传递的。

* `%rax` : 存放系统调用号
* `%rcx, %rdx, %rsi, %rdi, %r8, %r9`: 用来存放系统调用参数
* `syscall` : 系统调用指令





----

# X86 汇编

* 实模式 和 保护模式：说的是CPU的工作模式，CPU可以工作在实模式下，也可以工作在保护模式下。设置 寄存器`cr0=1` 来打开保护模式。
  * 实模式特点：直接面对物理内存。每个程序都可以访问任意物理内存位置
  * 保护模式：可以给代码的每个段设置权限，这样就提供了一点保护能力。至少可以保证数据段不会当成代码段执行。



## 汇编语言三类指令

* 汇编指令：机器码的助记符，有对应的机器码
* 伪指令：没有对应的机器码，由编译器执行，计算机并不执行
* 其他符号：如`+, -, *, /` ，由编译器识别，没有对应的机器码



## 硬件相关

* 三大总线：
  * 地址总线：传地址。`宽度`决定寻址范围
  * 数据总线：传数据。`宽度`决定一次能传多少数据
  * 控制总线：传命令。读，写，etc.



## 寄存器

* 8086有14个寄存器， 都是`16bit = 1word`
  * 通用寄存器：`AX, BX, CX, DX`
  * `SI, DI, SPS, BP, IP`
  * 段寄存器：`CS, SS, DS, ES`，寻址时，存放段地址的。
* 标志位寄存器
  * `ZF`: 零标志位，用来表示计算结果是否为 0.（哪些指令会影响该标志位？）
  * `PF`: 奇偶标志位，结果bit中，1的个数是基数还是偶数。（哪些指令会影响该标志位）
  * `SF`: 符号标志位，计算结果是否为负。（哪些指令会影响该标志位）
  * `CF`: 进位标志位，计算结果是否进位。（哪些指令会影响该标志位）
  * `OF`: 溢出标志位，计算结果是否溢出。（哪些指令会影响该标志位？和CF有啥区别？）
  * `TF` :
  * `IF` :



# 实模式

> 实模式工作在x86的16bit下。
>
> 实模式的汇编代码直接面向物理内存。里面所有的寻址都是针对于物理内存的。
>
> 所以在写代码的时候，我们必须清楚该代码最终会被加载到物理内存的什么位置，这样才可能正确的寻址!!



## 8086 寻址

> 寄存器：16bit
>
> 地址总线：20bit
>
> 寻址指的都是内存寻址

8086采用两个16bit地址合成一个20bit地址方法：

* 具体方法，`段地址寄存器` 的值左移4位，然后加上另一个16bit地址，这就构成了 20-bit地址。



### 代码段寻址

> 涉及寄存器：`cs, ip`. `cs:ip` 永远指向下一条要执行的指令！

如何修改 cs, ip 的值：

* 不能使用 `mov`
* `jmp`:
  * `jmp 3:0B16` `3`会给 `cs`，`0B16` 会给`ip`
  * `jmp ax`: ax中的值会给 `ip` . 
* `loop`
* `call`
* `int`

> 可以修改 `ip`, 或 `cs和ip` 的指令都称之为转移指令



**offset**

> `offset label`: **label** 相对于 **程序开始** 的地址

```assembly
assume cs:codesg
codesg segment
	start: 
		 mov ax, offset start; 相当于 mov ax, 0
	s:
		 mov ax, offset s    ; 相当于 mov ax, 3. 即：第一条指令3byte，s距离start偏移 3字节
		 
codesg ends

end s; end 用来指名程序的执行入口
```



**jmp**

```assembly
assume cs:codesg
codesg segment
	start: 
		 mov ax, 0
		 jmp short s; 该指令编译出来的机器码并不包含 jmp 的绝对地址，而是包含基于当前地址的偏移。
		 add ax, 1 
	s:
		 mov ax, offset s
		 
codesg ends

end s; end 用来指名程序的执行入口
```

> jmp short label, jmp near label.  编译出来的 机器码包含的都是基于当前指令位置的偏移。
>
> 段内近距离跳转



```assembly
jmp far ptr label; 编译的机器码会包含转移地址的 段地址:偏移地址。会修改 cs:ip
```



```assembly
; 转移地址在内存

mov ax, 0123H
mov ds:[0], ax
jmp word ptr ds:[0] ; 内存单元转移，段内转移. 仅修改ip

jmp word ptr ds:[0]; 段间转移
```



**call & ret**

> `ret`: 利用栈中的数据，修改 `ip` 的内容，从而实现近转移
>
> `retf`: 利用栈中的数据，修改 `cs:ip` 中的内容，从而实现远转移

```assembly
; 使用 label
call label; 当前ip压栈，转移到对应位置执行
;--- 等价于
push ip
jmp near ptr label

;-- 段间

call far ptr label
;--- 等价于
push cs
push ip
jmp far ptr label
```



```assembly
; 地址在寄存器中
call reg
;--- 等价于
push ip
jmp reg ; ip = reg。仅修改ip
```



```assembly
; 地址在内存中
call word ptr ds:[0]
call dword ptr ds:[0]
```



> call & ret 一起使用可以构建 子程序





### 数据段寻址

> `ds << 4 + offset`

```assembly
mov bx, 1000H
mov ds, bx
mov al, [0]; ds<<4 + 0 对应内存位置的值移动到 al 中

; 段前缀, 显示指名段前缀，不使用默认的ds。
mov ax, cs:[0]
```



```assembly
; bx + 立即数 表示偏移。
mov ax, [bx + 200]
mov ax, 200[bx]
mov ax [bx].200
```

```assembly
; 其它寻址方式
[bx + si]
[bx + di]
[bx + di + idata]
[bx + si + idata]
[bx + di + idata]
```





### 栈段

> 段寄存器：SS, 栈顶：SP
>
> 栈是不停向低地址部分扩张的。SS指向栈的最低地址。SP表示距离最低地址的 offset

```assembly
; 初始化栈顶

mov ax, 1000H
mov ss, ax
mov sp, 0010H ; sp 是 offset！

; 之后的 push，pop。就会自动修改 sp 的值了。
```

## 8086中断

### 内中断

* 内中断
  * 除法错误，比如：div 指令除0。中断类型码 `0`
  * 单步执行。（调试器？）。中断类型码 `1`
  * into 指令。中断类型码 `4`
  * int 指令。`int n` . 指令中的 `n` 是立即数，是提供给 `cpu` 的中断类型码

* 中断向量表：
  * 存放中断处理程序的入口地址。
  * 该表放在物理地址 `0x0, 0x03ff` 中。每个地址需要 `cs:ip`, 所以需要两个字（4字节）

* 进入中断的过程。（无需代码，硬件来操作的？
  * 从中断信息中取得中断类型码
  * 标志寄存器入栈（因为在中断过程中会改变标志寄存器的值，所以要先保存）
  * 设置标志寄存器的第8位 TF 和 第9位 IF 的值为0
  * CS内容入栈，IP内容入栈
  * 根据中断类型码指向的 处理程序入口设置 `cs:ip`
  * 以上这些都不是程序员干的事。（硬件自动处理的）
* 中断处理程序的写法：
  * 保存用到的寄存器（为了之后可以恢复）
  * 处理中断
  * 恢复用到的寄存器
  * 使用 ret返回



### 外中断

* 可屏蔽中断
* 不可屏蔽中断





## 8086端口读写

```assembly
in al, 60H; 从60号端口读数据
out 60H, al; 往 60号端口写数据
```



* 汇编地址
  * 在NASM 汇编语言里，每条语句的前面都可以有一个`标号`，以代表该指令的 **汇编地址** 。`infi jump near infi`
    * `标号`对应的汇编地址，其数值是源程序编译时候决定的
  * 汇编代码的第一条指令的汇编地址为0，然后向下累加
  * 如果程序并不是加载到物理地址 `0x0` 的位置执行，在汇编代码中用到 `标号` 寻址的地方需要注意⚠️



* 实模式下的寻址：与段寄存器息息相关。
  * `cs, ds, es, ss`
  * `cs`: 指令的基址寄存器
  * `ds`: 数据基址寄存器。`mov etc.` 命令的默认基址寄存器
  *  `es`: `extra segment`， 可以随便用
  * `ss`: 栈的基址寄存器。和 `push, pop` 相关？似乎存的是栈的最低地址。。
  * **谁读，谁写这些寄存器**



* 剩下的就是各个指令 和 这些寄存器之间的关系



# 实模式到保护模式





# 寻址



保护模式：

* GDT: global descriptor table, 用来设置段的基地址，大小，权限，etc。每条记录 64bits。下面是段的描述
  * <img src="https://img-blog.csdnimg.cn/01bc8c838afb4fe083abfe3865d3d038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0MzYxNDk=,size_16,color_FFFFFF,t_70" alt="image-20210807231950100" style="zoom:50%;" />
  * DPL：Descriptor Privilege Level：描述符特权级
  * `gdtr`: 寄存器，存放指向 GDT的指针。



* 段寄存器用来存取 指向GDT记录的指针偏移（为什么存偏移量即可？因为 gdtr 已经有基地址了）
  * 段寄存器存的值的解释：描述符索引，TI，RPL。描述符索引：13bits，TI：1bits，RPL：2bits
  * 描述符索引：注意是索引号，而非地址偏移！
  * TI = 0，从GDT中找索引。TI=1，从LDT找索引
  * RPL：request privilege level. 请求特权级



谁来设置GDT：

* 运行在最高特权级的代码。（booloader， 操作系统内核，etc）。应用程序就不要想了。

